# Microsoft Visual Studo

1. Настройка существующего проекта
    * Включаем C++17: Свойства проекта -> Общие -> Стандарт языка C++ -> Предварительная версия
    * Определяем удобный макрос, который бывает полезен на олимпиадах: Свойства проекта -> C/C++ -> Препроцессор -> Определения препроцессора -> Дописываем ONPC и, по желанию, _CRT_SECURE_NO_WARNINGS.

    ```c++
    #include <iostream>
    #include <fstream>

    int main() {
    #ifdef ONPC
        std::ifstream cin("input.txt"); // читаем из файла только локально
    #endif
        int a, b;
        std::cin >> a >> b;
        std::cout << a + b;
    }
    ```

2. Поиск Undefind-Behavor

    Copy-paste from [YDSA](https://ysda.gitlab.io/algorithms/environment.html).
    
    Visual Studio полный аналог санитайзеров получить не получится (а именно, undefined), но эмулировать -fsanitize=address более-менее можно.

    Для начала снова рассмотрим код с предупреждениями:

    img

    Зайдем в Проект -> Свойства. Дальше для всех конфигураций в свойствах конфигурации нужно выбрать следующий пункт:

    img

    Это аналог -Werror на сервере. Действительно, получаем ошибку компиляции:

    img

    То же самое и для конфигурации Release:

    img

    Рассмотрим теперь такой код:

    ```c++
    #include <iostream>
    #include <vector>

    int main() {
        size_t n;
        std::cin >> n;
        std::vector<int> data(n);
        for (size_t i = 0; i < n; ++i) {
            std::cin >> data[i];
        }
        std::cout << data[n] << "\n";
        return 0;
    }
    ```

    Тут есть очевидный выход за границы массива. В Visual Studio в Debug режиме полностью проверяются все операции со стандартными контейнерами. Таким образом, запуск этого кода в Release отработает успешно, а вот в Debug вы получите примерно такую ошибку:

    img

    К сожалению, если вы используете просто динамическую память (см. пример кода 2), то даже в Debug режиме все отработает успешно. Это еще один повод использовать стандартные контейнеры.

    Рассмотрим теперь третий пример, в котором происходит утечка памяти. В Visual Studio вы можете дописать в начало кода строки:

    ```c++
    #define _CRTDBG_MAP_ALLOC
    #include <stdlib.h>
    #include <crtdbg.h>
    ```

    Перед выходом из программы (перед return 0 в main например) добавьте строку

    ```c++
    _CrtDumpMemoryLeaks();
    ```

    Программа по-прежнему будет завершаться успешно, но в поток ошибок будет выведено следующее сообщение:

    img

    Проверим с delete[]:

    img

    Также обязательно запускайте ваше решение в конфигурации Release, потому что при этом включается -O2, что может приводить к другому поведению вашей программы (и на сервере тоже) в случае наличия в ней багов.
